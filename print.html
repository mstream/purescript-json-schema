<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PureScript JSON Schema</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html"><strong aria-hidden="true">1.</strong> Assessing the type of compatibility based on schemata differences</a></li><li class="chapter-item expanded "><a href="calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema.html"><strong aria-hidden="true">2.</strong> Calculating differences between schemata based on old JSON schema and new JSON schema</a></li><li class="chapter-item expanded "><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html"><strong aria-hidden="true">3.</strong> Finding JSON schema violations as a result of validating JSON value against JSON schema</a></li><li class="chapter-item expanded "><a href="printing-a-json-valuerepresenting-a-json-schema.html"><strong aria-hidden="true">4.</strong> Printing a JSON valuerepresenting a JSON schema</a></li><li class="chapter-item expanded "><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html"><strong aria-hidden="true">5.</strong> Producing a JSON schema or an error as a result of parsing JSON value</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript JSON Schema</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="assessing-the-type-of-compatibility-based-on-schemata-differences"><a class="header" href="#assessing-the-type-of-compatibility-based-on-schemata-differences">Assessing the type of compatibility based on schemata differences</a></h1>
<h2 id="schema"><a class="header" href="#schema">Schema</a></h2>
<pre class="mermaid">flowchart LR
    subgraph inputs
        input_desc_0[&quot;schemata differences&quot;]
    end
    subgraph output
        output_desc[&quot;the type of compatibility&quot;]
    end
    inputs --&gt; output
</pre>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p><em>Backward compatibility</em> - an ability of a system to understand input intended for previous
versions of itself</p>
<p><em>Forward compatibility</em> - an ability of a system to understand input intended for future versions
of itself</p>
<p><em>Full compatibility</em> - backward and forward compatibility combined</p>
<p><em>No compatibility</em> - neither level of compatibility</p>
<p>Maintaining backward and forward compatibility is important for
minimizing disruption<br />
and ensuring smooth transitions when updating JSON schemas.</p>
<pre class="mermaid">flowchart LR
    subgraph data writers
        current_writer(&quot;writer&quot;)
        next_writer(&quot;writer&lt;sub&gt;+1&lt;/sub&gt;&quot;)
    end
    subgraph data readers
        current_reader(&quot;reader&quot;)
        next_reader(&quot;reader&lt;sub&gt;+1&lt;/sub&gt;&quot;)
    end
    current_writer --&gt; current_reader
    current_writer --&gt;|backward compatibility| next_reader
    next_writer --&gt;|forward compatibility| current_reader
</pre>
<pre class="mermaid">flowchart LR
    subgraph data writers
        current_writer(&quot;writer&quot;)
        next_writer(&quot;writer&lt;sub&gt;+1&lt;/sub&gt;&quot;)
    end
    subgraph data readers
        current_reader(&quot;reader&quot;)
        next_reader(&quot;reader&lt;sub&gt;+1&lt;/sub&gt;&quot;)
    end
    current_writer --&gt; current_reader
    current_writer --&gt;|backward compatibility| next_reader
    next_writer --&gt;|forward compatibility| current_reader
</pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<ul>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-reduction-of-accepted-types-by-a-number">assessing the type of compatibility based on reduction of accepted types by a number</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-extension-of-accepted-types-by-a-number">assessing the type of compatibility based on extension of accepted types by a number</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-change-of-accepted-type-from-integer-to-number">assessing the type of compatibility based on change of accepted type from integer to number</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-an-accepted-type-change-from-null-to-boolean">assessing the type of compatibility based on an accepted type change from null to boolean</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-extending-set-of-accepted-value-types-from-numbers-to-numbers-and-integers">assessing the type of compatibility based on extending set of accepted value types from numbers to numbers and integers</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-change-of-accepted-type-from-number-to-integer">assessing the type of compatibility based on change of accepted type from number to integer</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-no-differences">assessing the type of compatibility based on no differences</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-extension-of-accepted-types-by-an-additional-type">assessing the type of compatibility based on extension of accepted types by an additional type</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-reduction-of-accepted-types">assessing the type of compatibility based on reduction of accepted types</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-old-and-new-value-of-multipleof-being-not-each-others-factors">assessing the type of compatibility based on old and new value of multipleOf being not each other's factors</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-number-values-being-extended">assessing the type of compatibility based on the range of allowed number values being extended</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-the-old-value-of-multipleof-being-divisible-by-the-new-one">assessing the type of compatibility based on the old value of multipleOf being divisible by the new one</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-the-new-value-of-multipleof-being-divisible-by-the-old-one">assessing the type of compatibility based on the new value of multipleOf being divisible by the old one</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-the-range-gets-unconstrained">assessing the type of compatibility based on the range gets unconstrained</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-values-being-reduced-using-the-exclusive-version-of-constraints">assessing the type of compatibility based on the range of allowed values being reduced using the exclusive version of constraints</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-number-values-being-extended-and-reduced-at-the-same-time-using-exclusive-versions-of-constraints">assessing the type of compatibility based on the range of allowed number values being extended and reduced at the same time using exclusive versions of constraints</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-number-values-being-extended-and-reduced-at-the-same-time">assessing the type of compatibility based on the range of allowed number values being extended and reduced at the same time</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-values-being-reduced">assessing the type of compatibility based on the range of allowed values being reduced</a></p>
</li>
<li>
<p><a href="assessing-the-type-of-compatibility-based-on-schemata-differences.html#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-values-being-shifted">assessing the type of compatibility based on the range of allowed values being shifted</a></p>
</li>
</ul>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-reduction-of-accepted-types-by-a-number"><a class="header" href="#assessing-the-type-of-compatibility-based-on-reduction-of-accepted-types-by-a-number">assessing the type of compatibility based on reduction of accepted types by a number</a></h3>
<p>In this situation, Because not every integer is a number, such a change
is forward compatible.. Therefore, such a change is forward compatible.</p>
<p><em>Input:</em></p>
<p>reduction of accepted types by a number:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of accepted JSON value types from</p>
<ul>
<li>
<p>integer</p>
</li>
<li>
<p>number</p>
</li>
</ul>
<p>to</p>
<ul>
<li>integer</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>forward compatibility:</p>
<blockquote>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the set of allowed JSON value types has been reduced by number</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-extension-of-accepted-types-by-a-number"><a class="header" href="#assessing-the-type-of-compatibility-based-on-extension-of-accepted-types-by-a-number">assessing the type of compatibility based on extension of accepted types by a number</a></h3>
<p>In this situation, Because not every integer is a number, such a change
is backward compatible.. Therefore, such a change is backward
compatible.</p>
<p><em>Input:</em></p>
<p>extension of accepted types by a number:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of accepted JSON value types from</p>
<ul>
<li>integer</li>
</ul>
<p>to</p>
<ul>
<li>
<p>integer</p>
</li>
<li>
<p>number</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>backward compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the set of allowed JSON value types has been extended by number</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-change-of-accepted-type-from-integer-to-number"><a class="header" href="#assessing-the-type-of-compatibility-based-on-change-of-accepted-type-from-integer-to-number">assessing the type of compatibility based on change of accepted type from integer to number</a></h3>
<p>In this situation, Because every integer is a number, but not vice
versa, such a change is backward compatible.. Therefore, such a change
is backward compatible.</p>
<p><em>Input:</em></p>
<p>change of accepted type from integer to number:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of accepted JSON value types from</p>
<ul>
<li>integer</li>
</ul>
<p>to</p>
<ul>
<li>number</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>backward compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the set of allowed JSON value types has been extended by number</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-an-accepted-type-change-from-null-to-boolean"><a class="header" href="#assessing-the-type-of-compatibility-based-on-an-accepted-type-change-from-null-to-boolean">assessing the type of compatibility based on an accepted type change from null to boolean</a></h3>
<p>In this situation, Because no boolean value can satisfy null JSON type
constraint, and vice versa, such a change is incompatible.. Therefore,
such a change is not compatible.</p>
<p><em>Input:</em></p>
<p>an accepted type change from null to boolean:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of accepted JSON value types from</p>
<ul>
<li>null</li>
</ul>
<p>to</p>
<ul>
<li>boolean</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>no compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the set of allowed JSON value types has been extended by boolean</p>
</li>
</ul>
</li>
</ul>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the set of allowed JSON value types has been reduced by null</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-extending-set-of-accepted-value-types-from-numbers-to-numbers-and-integers"><a class="header" href="#assessing-the-type-of-compatibility-based-on-extending-set-of-accepted-value-types-from-numbers-to-numbers-and-integers">assessing the type of compatibility based on extending set of accepted value types from numbers to numbers and integers</a></h3>
<p>In this situation, every integer is also a number so this kind of
difference does not have any implact. Therefore, such a change is fully
compatible.</p>
<p><em>Input:</em></p>
<p>extending set of accepted value types from numbers to numbers and
integers:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of accepted JSON value types from</p>
<ul>
<li>number</li>
</ul>
<p>to</p>
<ul>
<li>
<p>integer</p>
</li>
<li>
<p>number</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>full compatibility:</p>
<blockquote>
<p>✓</p>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-change-of-accepted-type-from-number-to-integer"><a class="header" href="#assessing-the-type-of-compatibility-based-on-change-of-accepted-type-from-number-to-integer">assessing the type of compatibility based on change of accepted type from number to integer</a></h3>
<p>In this situation, Because every integer is a number, but not vice
versa, such a change is forward compatible.. Therefore, such a change is
forward compatible.</p>
<p><em>Input:</em></p>
<p>change of accepted type from number to integer:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of accepted JSON value types from</p>
<ul>
<li>number</li>
</ul>
<p>to</p>
<ul>
<li>integer</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>forward compatibility:</p>
<blockquote>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the set of allowed JSON value types has been reduced by number</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-no-differences"><a class="header" href="#assessing-the-type-of-compatibility-based-on-no-differences">assessing the type of compatibility based on no differences</a></h3>
<p>In this situation, identical schemata cannot be incompatible with each
other. Therefore, such a change is fully compatible.</p>
<p><em>Input:</em></p>
<p>no differences:</p>
<blockquote>
<p>∅</p>
</blockquote>
<p><em>Output:</em></p>
<p>full compatibility:</p>
<blockquote>
<p>✓</p>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-extension-of-accepted-types-by-an-additional-type"><a class="header" href="#assessing-the-type-of-compatibility-based-on-extension-of-accepted-types-by-an-additional-type">assessing the type of compatibility based on extension of accepted types by an additional type</a></h3>
<p>In this situation, Because more value types than before are accepted,
this change is backward compatible.. Therefore, such a change is
backward compatible.</p>
<p><em>Input:</em></p>
<p>extension of accepted types by an additional type:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of accepted JSON value types from</p>
<ul>
<li>null</li>
</ul>
<p>to</p>
<ul>
<li>
<p>boolean</p>
</li>
<li>
<p>null</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>backward compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the set of allowed JSON value types has been extended by boolean</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-reduction-of-accepted-types"><a class="header" href="#assessing-the-type-of-compatibility-based-on-reduction-of-accepted-types">assessing the type of compatibility based on reduction of accepted types</a></h3>
<p>In this situation, Because less value types than before are accepted,
this change is backward compatible.. Therefore, such a change is forward
compatible.</p>
<p><em>Input:</em></p>
<p>reduction of accepted types:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of accepted JSON value types from</p>
<ul>
<li>
<p>boolean</p>
</li>
<li>
<p>null</p>
</li>
</ul>
<p>to</p>
<ul>
<li>null</li>
</ul>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>forward compatibility:</p>
<blockquote>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the set of allowed JSON value types has been reduced by boolean</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-old-and-new-value-of-multipleof-being-not-each-others-factors"><a class="header" href="#assessing-the-type-of-compatibility-based-on-old-and-new-value-of-multipleof-being-not-each-others-factors">assessing the type of compatibility based on old and new value of multipleOf being not each other's factors</a></h3>
<p>In this situation, there are potentially some numbers that are not
divisible by neither of multipleOf values. Therefore, such a change is
not compatible.</p>
<p><em>Input:</em></p>
<p>old and new value of multipleOf being not each other's factors:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of multipleOf from 2.0 to 5.0</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>no compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the new multiple constraint of 5.0 is not a factor of the olf multiple constraint of 2.0</p>
</li>
</ul>
</li>
</ul>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the old multiple constraint of 2.0 is not a factor of the new multiple constraint of 5.0</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-the-range-of-allowed-number-values-being-extended"><a class="header" href="#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-number-values-being-extended">assessing the type of compatibility based on the range of allowed number values being extended</a></h3>
<p>In this situation, all numbers from the new, longer range fall into the
old, shorter range. Therefore, such a change is backward compatible.</p>
<p><em>Input:</em></p>
<p>the range of allowed number values being extended:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of maximum from 15.0 to 20.0</p>
</li>
<li>
<p>JSON schema path: #</p>
<p>change of minimum from 10.0 to 5.0</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>backward compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been extended by [5.0,10.0) and (15.0,20.0]</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-the-old-value-of-multipleof-being-divisible-by-the-new-one"><a class="header" href="#assessing-the-type-of-compatibility-based-on-the-old-value-of-multipleof-being-divisible-by-the-new-one">assessing the type of compatibility based on the old value of multipleOf being divisible by the new one</a></h3>
<p>In this situation, all numbers from the new range fall into the old,
unconstrained one. Therefore, such a change is forward compatible.</p>
<p><em>Input:</em></p>
<p>the old value of multipleOf being divisible by the new one:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of maximum from unspecified to 20.0</p>
</li>
<li>
<p>JSON schema path: #</p>
<p>change of minimum from unspecified to 5.0</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>forward compatibility:</p>
<blockquote>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been reduced by (-Infinity,5.0) and (20.0,Infinity)</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-the-new-value-of-multipleof-being-divisible-by-the-old-one"><a class="header" href="#assessing-the-type-of-compatibility-based-on-the-new-value-of-multipleof-being-divisible-by-the-old-one">assessing the type of compatibility based on the new value of multipleOf being divisible by the old one</a></h3>
<p>In this situation, Because every multiple the new value is also a
multiple of the old value, such a change is backward compatible.
Therefore, such a change is backward compatible.</p>
<p><em>Input:</em></p>
<p>the new value of multipleOf being divisible by the old one:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of multipleOf from 2.0 to 4.0</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>backward compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the new multiple constraint of 4.0 is not a factor of the olf multiple constraint of 2.0</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-the-range-gets-unconstrained"><a class="header" href="#assessing-the-type-of-compatibility-based-on-the-range-gets-unconstrained">assessing the type of compatibility based on the range gets unconstrained</a></h3>
<p>In this situation, all numbers from the old range fall into the new,
unconstrained one. Therefore, such a change is backward compatible.</p>
<p><em>Input:</em></p>
<p>the range gets unconstrained:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of maximum from 20.0 to unspecified</p>
</li>
<li>
<p>JSON schema path: #</p>
<p>change of minimum from 5.0 to unspecified</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>backward compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been extended by (-Infinity,5.0] and (20.0,Infinity)</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-the-range-of-allowed-values-being-reduced-using-the-exclusive-version-of-constraints"><a class="header" href="#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-values-being-reduced-using-the-exclusive-version-of-constraints">assessing the type of compatibility based on the range of allowed values being reduced using the exclusive version of constraints</a></h3>
<p>In this situation, all numbers from the new, shorted range fall into the
old, longer range. Therefore, such a change is forward compatible.</p>
<p><em>Input:</em></p>
<p>the range of allowed values being reduced using the exclusive version of
constraints:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of exclusiveMaximum from 20.0 to 15.0</p>
</li>
<li>
<p>JSON schema path: #</p>
<p>change of exclusiveMinimum from 5.0 to 10.0</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>forward compatibility:</p>
<blockquote>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been reduced by (5.0,10.0] and [15.0,20.0)</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-the-range-of-allowed-number-values-being-extended-and-reduced-at-the-same-time-using-exclusive-versions-of-constraints"><a class="header" href="#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-number-values-being-extended-and-reduced-at-the-same-time-using-exclusive-versions-of-constraints">assessing the type of compatibility based on the range of allowed number values being extended and reduced at the same time using exclusive versions of constraints</a></h3>
<p>In this situation, there are some numbers which do not fall into neither
old nor new range. Therefore, such a change is not compatible.</p>
<p><em>Input:</em></p>
<p>the range of allowed number values being extended and reduced at the
same time using exclusive versions of constraints:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of exclusiveMaximum from 15.0 to 20.0</p>
</li>
<li>
<p>JSON schema path: #</p>
<p>change of exclusiveMinimum from 5.0 to 10.0</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>no compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been extended by [15.0,20.0)</p>
</li>
</ul>
</li>
</ul>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been reduced by (5.0,10.0]</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-the-range-of-allowed-number-values-being-extended-and-reduced-at-the-same-time"><a class="header" href="#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-number-values-being-extended-and-reduced-at-the-same-time">assessing the type of compatibility based on the range of allowed number values being extended and reduced at the same time</a></h3>
<p>In this situation, there are some numbers which do not fall into neither
old nor new range. Therefore, such a change is not compatible.</p>
<p><em>Input:</em></p>
<p>the range of allowed number values being extended and reduced at the
same time:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of maximum from 15.0 to 20.0</p>
</li>
<li>
<p>JSON schema path: #</p>
<p>change of minimum from 5.0 to 10.0</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>no compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been extended by (15.0,20.0]</p>
</li>
</ul>
</li>
</ul>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been reduced by [5.0,10.0)</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-the-range-of-allowed-values-being-reduced"><a class="header" href="#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-values-being-reduced">assessing the type of compatibility based on the range of allowed values being reduced</a></h3>
<p>In this situation, all numbers from the new, shorted range fall into the
old, longer range. Therefore, such a change is forward compatible.</p>
<p><em>Input:</em></p>
<p>the range of allowed values being reduced:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of maximum from 20.0 to 15.0</p>
</li>
<li>
<p>JSON schema path: #</p>
<p>change of minimum from 5.0 to 10.0</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>forward compatibility:</p>
<blockquote>
<p>Reasons for breaking the backward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been reduced by [5.0,10.0) and (15.0,20.0]</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="assessing-the-type-of-compatibility-based-on-the-range-of-allowed-values-being-shifted"><a class="header" href="#assessing-the-type-of-compatibility-based-on-the-range-of-allowed-values-being-shifted">assessing the type of compatibility based on the range of allowed values being shifted</a></h3>
<p>In this situation, all numbers from the new, longer range fall into the
old, shorter range. Therefore, such a change is backward compatible.</p>
<p><em>Input:</em></p>
<p>the range of allowed values being shifted:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #</p>
<p>change of exclusiveMaximum from 15.0 to 20.0</p>
</li>
<li>
<p>JSON schema path: #</p>
<p>change of exclusiveMinimum from 10.0 to 5.0</p>
</li>
</ul>
</blockquote>
<p><em>Output:</em></p>
<p>backward compatibility:</p>
<blockquote>
<p>Reasons for breaking the forward compatibility:</p>
<ul>
<li>
<ul>
<li>
<p>schema path: #</p>
<p>the range of allowed values has been extended by (5.0,10.0] and [15.0,20.0)</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema"><a class="header" href="#calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema">Calculating differences between schemata based on old JSON schema and new JSON schema</a></h1>
<h2 id="schema-1"><a class="header" href="#schema-1">Schema</a></h2>
<pre class="mermaid">flowchart LR
    subgraph inputs
        input_desc_0[&quot;new JSON schema&quot;]
        input_desc_1[&quot;old JSON schema&quot;]
    end
    subgraph output
        output_desc[&quot;differences between schemata&quot;]
    end
    inputs --&gt; output
</pre>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<p>Calculating JSON Schema Difference is a process used to identify the
changes between two JSON schemata.<br />
It is used to to see what has been added, removed, or changed.<br />
This is useful for tracking changes over time, understanding the impact
of changes, and managing versions of a schema.<br />
It can also be used to generate a diff report or to automate the process
of updating dependent systems or documentation when a schema changes.</p>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<ul>
<li>
<p>comparing identical schemata yields no differences</p>
</li>
<li>
<p>comparing different schemata yields differences</p>
</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<ul>
<li>
<p><a href="calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema.html#calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-less-than-or-equal-to-some-number-and-json-schema-accepting-only-number-less-than-or-equal-to-other-number">calculating differences between schemata based on JSON schema accepting only number less than or equal to some number and JSON schema accepting only number less than or equal to other number</a></p>
</li>
<li>
<p><a href="calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema.html#calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-greater-than-or-equal-to-some-number-and-json-schema-accepting-only-number-greater-than-or-equal-to-other-number">calculating differences between schemata based on JSON schema accepting only number greater than or equal to some number and JSON schema accepting only number greater than or equal to other number</a></p>
</li>
<li>
<p><a href="calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema.html#calculating-differences-between-schemata-based-on-json-schema-accepting-only-multiples-of-a-some-number-and-json-schema-accepting-only-multiples-of-other-number">calculating differences between schemata based on JSON schema accepting only multiples of a some number and JSON schema accepting only multiples of other number</a></p>
</li>
<li>
<p><a href="calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema.html#calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-greater-than-some-number-and-json-schema-accepting-only-number-greater-than-other-number">calculating differences between schemata based on JSON schema accepting only number greater than some number and JSON schema accepting only number greater than other number</a></p>
</li>
<li>
<p><a href="calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema.html#calculating-differences-between-schemata-based-on-json-schema-accepting-only-some-type-and-json-schema-accepting-only-other-type">calculating differences between schemata based on JSON schema accepting only some type and JSON schema accepting only other type</a></p>
</li>
<li>
<p><a href="calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema.html#calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-less-than-some-number-and-json-schema-accepting-only-number-less-than-other-number">calculating differences between schemata based on JSON schema accepting only number less than some number and JSON schema accepting only number less than other number</a></p>
</li>
<li>
<p><a href="calculating-differences-between-schemata-based-on-old-json-schema-and-new-json-schema.html#calculating-differences-between-schemata-based-on-same-schema-and-some-schema">calculating differences between schemata based on same schema and some schema</a></p>
</li>
</ul>
<hr />
<h3 id="calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-less-than-or-equal-to-some-number-and-json-schema-accepting-only-number-less-than-or-equal-to-other-number"><a class="header" href="#calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-less-than-or-equal-to-some-number-and-json-schema-accepting-only-number-less-than-or-equal-to-other-number">calculating differences between schemata based on JSON schema accepting only number less than or equal to some number and JSON schema accepting only number less than or equal to other number</a></h3>
<p>Any change of maximum inclusive keyword value  is considered a
difference.</p>
<p><em>Input:</em></p>
<p>JSON schema accepting only number less than or equal to other number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;maximum&quot;: 4
}
</code></pre>
</blockquote>
<p>JSON schema accepting only number less than or equal to some number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;maximum&quot;: 2
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a change in inclusive maximum value:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #/maximum</p>
<p>change of maximum from 2.0 to 4.0</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-greater-than-or-equal-to-some-number-and-json-schema-accepting-only-number-greater-than-or-equal-to-other-number"><a class="header" href="#calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-greater-than-or-equal-to-some-number-and-json-schema-accepting-only-number-greater-than-or-equal-to-other-number">calculating differences between schemata based on JSON schema accepting only number greater than or equal to some number and JSON schema accepting only number greater than or equal to other number</a></h3>
<p>Any change of minimum inclusive keyword value is considered a
difference.</p>
<p><em>Input:</em></p>
<p>JSON schema accepting only number greater than or equal to other number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;minimum&quot;: 4
}
</code></pre>
</blockquote>
<p>JSON schema accepting only number greater than or equal to some number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;minimum&quot;: 2
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a change in inclusive minimum value:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #/minimum</p>
<p>change of minimum from 2.0 to 4.0</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="calculating-differences-between-schemata-based-on-json-schema-accepting-only-multiples-of-a-some-number-and-json-schema-accepting-only-multiples-of-other-number"><a class="header" href="#calculating-differences-between-schemata-based-on-json-schema-accepting-only-multiples-of-a-some-number-and-json-schema-accepting-only-multiples-of-other-number">calculating differences between schemata based on JSON schema accepting only multiples of a some number and JSON schema accepting only multiples of other number</a></h3>
<p>Any change of multipleOf keyword is considered a difference.</p>
<p><em>Input:</em></p>
<p>JSON schema accepting only multiples of other number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;multipleOf&quot;: 4
}
</code></pre>
</blockquote>
<p>JSON schema accepting only multiples of a some number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;multipleOf&quot;: 2
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a change in accepted value factor:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #/multipleOf</p>
<p>change of multipleOf from 2.0 to 4.0</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-greater-than-some-number-and-json-schema-accepting-only-number-greater-than-other-number"><a class="header" href="#calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-greater-than-some-number-and-json-schema-accepting-only-number-greater-than-other-number">calculating differences between schemata based on JSON schema accepting only number greater than some number and JSON schema accepting only number greater than other number</a></h3>
<p>Any change of minimum exclusive keyword value  is considered a
difference.</p>
<p><em>Input:</em></p>
<p>JSON schema accepting only number greater than other number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;exclusiveMinimum&quot;: 4
}
</code></pre>
</blockquote>
<p>JSON schema accepting only number greater than some number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;exclusiveMinimum&quot;: 2
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a change in exclusive minimum value:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #/exclusiveMinimum</p>
<p>change of exclusiveMinimum from 2.0 to 4.0</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="calculating-differences-between-schemata-based-on-json-schema-accepting-only-some-type-and-json-schema-accepting-only-other-type"><a class="header" href="#calculating-differences-between-schemata-based-on-json-schema-accepting-only-some-type-and-json-schema-accepting-only-other-type">calculating differences between schemata based on JSON schema accepting only some type and JSON schema accepting only other type</a></h3>
<p>Any change of expected JSON value type  is considered a difference.</p>
<p><em>Input:</em></p>
<p>JSON schema accepting only other type:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;boolean&quot;
  ]
}
</code></pre>
</blockquote>
<p>JSON schema accepting only some type:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;null&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a change in accepted value type:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #/type</p>
<p>change of accepted JSON value types from</p>
<ul>
<li>null</li>
</ul>
<p>to</p>
<ul>
<li>boolean</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-less-than-some-number-and-json-schema-accepting-only-number-less-than-other-number"><a class="header" href="#calculating-differences-between-schemata-based-on-json-schema-accepting-only-number-less-than-some-number-and-json-schema-accepting-only-number-less-than-other-number">calculating differences between schemata based on JSON schema accepting only number less than some number and JSON schema accepting only number less than other number</a></h3>
<p>Any change of maximum exclusive keyword value  is considered a
difference.</p>
<p><em>Input:</em></p>
<p>JSON schema accepting only number less than other number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;exclusiveMaximum&quot;: 4
}
</code></pre>
</blockquote>
<p>JSON schema accepting only number less than some number:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;exclusiveMaximum&quot;: 2
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a change in exclusive maximum value:</p>
<blockquote>
<ul>
<li>
<p>JSON schema path: #/exclusiveMaximum</p>
<p>change of exclusiveMaximum from 2.0 to 4.0</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="calculating-differences-between-schemata-based-on-same-schema-and-some-schema"><a class="header" href="#calculating-differences-between-schemata-based-on-same-schema-and-some-schema">calculating differences between schemata based on same schema and some schema</a></h3>
<p>Comparison of two identical schemata yields no differences.</p>
<p><em>Input:</em></p>
<p>some schema:</p>
<blockquote>
<pre><code class="language-json">false
</code></pre>
</blockquote>
<p>same schema:</p>
<blockquote>
<pre><code class="language-json">false
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no differences:</p>
<blockquote>
<p>∅</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema">Finding JSON schema violations as a result of validating JSON value against JSON schema</a></h1>
<h2 id="schema-2"><a class="header" href="#schema-2">Schema</a></h2>
<pre class="mermaid">flowchart LR
    subgraph inputs
        input_desc_0[&quot;JSON value&quot;]
        input_desc_1[&quot;JSON schema&quot;]
    end
    subgraph output
        output_desc[&quot;JSON schema violations&quot;]
    end
    inputs --&gt; output
</pre>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<p>JSON validation is a specification for validating the structure and data
types of JSON values.<br />
It allows you to specify the required properties, the types of values,
the format of the data, and other constraints for a JSON object.<br />
This is useful for ensuring that the data received or sent in a JSON
format is as expected and can be processed correctly.<br />
It helps to catch errors early, improve data quality, and reduce the
amount of code needed for data validation.</p>
<h2 id="properties-1"><a class="header" href="#properties-1">Properties</a></h2>
<ul>
<li>
<p>'true' JSON schema does not impose any constraints</p>
</li>
<li>
<p>'false' JSON schema rejects anything</p>
</li>
<li>
<p>any JSON value passes validation against 'empty object' JSON schema</p>
</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<ul>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-a-multiple-of-x-against-schema-accepting-only-numbers-which-are-multiples-of-x">finding JSON schema violations as a result of validating a multiple of x against schema accepting only numbers which are multiples of x</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-a-boolean-value-against-schema-accepting-only-nulls-or-strings">finding JSON schema violations as a result of validating a boolean value against schema accepting only nulls or strings</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-json-number-value-against-json-schema-accepting-only-numbers">finding JSON schema violations as a result of validating JSON number value against JSON schema accepting only numbers</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-json-null-value-against-json-schema-accepting-booleans-nulls-and-strings">finding JSON schema violations as a result of validating JSON null value against JSON schema accepting booleans, nulls and strings</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-json-number-value-which-happens-to-be-an-integer-against-json-schema-accepting-any-numbers">finding JSON schema violations as a result of validating JSON number value which happens to be an integer against JSON schema accepting any numbers</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-a-fractional-number-against-schema-accepting-only-whole-numbers">finding JSON schema violations as a result of validating a fractional number against schema accepting only whole numbers</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-a-multiple-of-25-against-a-schema-accepting-only-multiples-of-25">finding JSON schema violations as a result of validating a multiple of 2.5 against a schema accepting only multiples of 2.5</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-exclusive-allowed-value-set">finding JSON schema violations as a result of validating number at the schema's maximum allowed values boundary against a schema with a maximum exclusive allowed value set</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-an-array-containing-some-duplicated-strings-against-schema-not-accepting-duplicates">finding JSON schema violations as a result of validating an array containing some duplicated strings against schema not accepting duplicates</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-an-array-containing-a-mixture-of-null-and-boolean-values-to-a-schema-accepting-only-arrays-of-nulls-against-schema-accepting-only-arrays-of-nulls">finding JSON schema violations as a result of validating an array containing a mixture of null and boolean values to a schema accepting only arrays of nulls against schema accepting only arrays of nulls</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-not-a-multiple-of-25-against-a-schema-accepting-only-multiples-of-25">finding JSON schema violations as a result of validating not a multiple of 2.5 against a schema accepting only multiples of 2.5</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-number-below-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-exclusive-allowed-value-set">finding JSON schema violations as a result of validating number below the schema's maximum allowed values boundary against a schema with a maximum exclusive allowed value set</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-exclusive-allowed-value-set">finding JSON schema violations as a result of validating number at the schema's minimum allowed values boundary against a schema with a minimum exclusive allowed value set</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-inclusive-allowed-value-set">finding JSON schema violations as a result of validating number at the schema's maximum allowed values boundary against a schema with a maximum inclusive allowed value set</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-inclusive-allowed-value-set">finding JSON schema violations as a result of validating number at the schema's minimum allowed values boundary against a schema with a minimum inclusive allowed value set</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-number-exceeding-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-inclusive-allowed-value-set">finding JSON schema violations as a result of validating number exceeding the schema's maximum allowed values boundary against a schema with a maximum inclusive allowed value set</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-number-below-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-exclusive-allowed-value-set">finding JSON schema violations as a result of validating number below the schema's minimum allowed values boundary against a schema with a minimum exclusive allowed value set</a></p>
</li>
<li>
<p><a href="finding-json-schema-violations-as-a-result-of-validating-json-value-against-json-schema.html#finding-json-schema-violations-as-a-result-of-validating-number-exceeding-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-inclusive-allowed-value-set">finding JSON schema violations as a result of validating number exceeding the schema's minimum allowed values boundary against a schema with a minimum inclusive allowed value set</a></p>
</li>
</ul>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-a-multiple-of-x-against-schema-accepting-only-numbers-which-are-multiples-of-x"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-a-multiple-of-x-against-schema-accepting-only-numbers-which-are-multiples-of-x">finding JSON schema violations as a result of validating a multiple of x against schema accepting only numbers which are multiples of x</a></h3>
<p>Because a JSON number value is a multiple of the factor desired by the
schema, such a value is valid.</p>
<p><em>Input:</em></p>
<p>a multiple of x:</p>
<blockquote>
<pre><code class="language-json">7.5
</code></pre>
</blockquote>
<p>schema accepting only numbers which are multiples of x:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;multipleOf&quot;: 2.5,
  &quot;type&quot;: [
    &quot;number&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no violations:</p>
<blockquote>
<p>∅</p>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-a-boolean-value-against-schema-accepting-only-nulls-or-strings"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-a-boolean-value-against-schema-accepting-only-nulls-or-strings">finding JSON schema violations as a result of validating a boolean value against schema accepting only nulls or strings</a></h3>
<p>Because the value is neither null or string, such a value is invalid.</p>
<p><em>Input:</em></p>
<p>a boolean value:</p>
<blockquote>
<pre><code class="language-json">true
</code></pre>
</blockquote>
<p>schema accepting only nulls or strings:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;null&quot;,
    &quot;string&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a type mismatch violation:</p>
<blockquote>
<ul>
<li>
<p>JSON value path: <code>$</code><br />
JSON schema path: <code>#/type</code></p>
<p>Invalid type. Expected nullorstring but got boolean.</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-json-number-value-against-json-schema-accepting-only-numbers"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-json-number-value-against-json-schema-accepting-only-numbers">finding JSON schema violations as a result of validating JSON number value against JSON schema accepting only numbers</a></h3>
<p>Because a JSON value directly matches schema's only 'type' keyword item,
such a value is valid.</p>
<p><em>Input:</em></p>
<p>JSON number value:</p>
<blockquote>
<pre><code class="language-json">2.5
</code></pre>
</blockquote>
<p>JSON schema accepting only numbers:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;number&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no violations:</p>
<blockquote>
<p>∅</p>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-json-null-value-against-json-schema-accepting-booleans-nulls-and-strings"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-json-null-value-against-json-schema-accepting-booleans-nulls-and-strings">finding JSON schema violations as a result of validating JSON null value against JSON schema accepting booleans, nulls and strings</a></h3>
<p>Because a JSON value directly matches one of schema's 'type' keyword
items, such a value is valid.</p>
<p><em>Input:</em></p>
<p>JSON null value:</p>
<blockquote>
<pre><code class="language-json">null
</code></pre>
</blockquote>
<p>JSON schema accepting booleans, nulls and strings:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;boolean&quot;,
    &quot;null&quot;,
    &quot;string&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no violations:</p>
<blockquote>
<p>∅</p>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-json-number-value-which-happens-to-be-an-integer-against-json-schema-accepting-any-numbers"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-json-number-value-which-happens-to-be-an-integer-against-json-schema-accepting-any-numbers">finding JSON schema violations as a result of validating JSON number value which happens to be an integer against JSON schema accepting any numbers</a></h3>
<p>Because a JSON value indirectly matches schema's only 'type' keyword
item, such a value is valid.</p>
<p><em>Input:</em></p>
<p>JSON number value which happens to be an integer:</p>
<blockquote>
<pre><code class="language-json">1
</code></pre>
</blockquote>
<p>JSON schema accepting any numbers:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;number&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no violations:</p>
<blockquote>
<p>∅</p>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-a-fractional-number-against-schema-accepting-only-whole-numbers"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-a-fractional-number-against-schema-accepting-only-whole-numbers">finding JSON schema violations as a result of validating a fractional number against schema accepting only whole numbers</a></h3>
<p>Because the schema accepts only whole numbers, such a value is invalid.</p>
<p><em>Input:</em></p>
<p>a fractional number:</p>
<blockquote>
<pre><code class="language-json">1.5
</code></pre>
</blockquote>
<p>schema accepting only whole numbers:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;integer&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a type mismatch violation:</p>
<blockquote>
<ul>
<li>
<p>JSON value path: <code>$</code><br />
JSON schema path: <code>#/type</code></p>
<p>Invalid type. Expected integer but got number.</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-a-multiple-of-25-against-a-schema-accepting-only-multiples-of-25"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-a-multiple-of-25-against-a-schema-accepting-only-multiples-of-25">finding JSON schema violations as a result of validating a multiple of 2.5 against a schema accepting only multiples of 2.5</a></h3>
<p>Because the schema accepts any multiples of 2.5, such a value is valid.</p>
<p><em>Input:</em></p>
<p>a multiple of 2.5:</p>
<blockquote>
<pre><code class="language-json">7.5
</code></pre>
</blockquote>
<p>a schema accepting only multiples of 2.5:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;multipleOf&quot;: 2.5,
  &quot;type&quot;: [
    &quot;number&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no violations:</p>
<blockquote>
<p>∅</p>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-exclusive-allowed-value-set"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-exclusive-allowed-value-set">finding JSON schema violations as a result of validating number at the schema's maximum allowed values boundary against a schema with a maximum exclusive allowed value set</a></h3>
<p>Because the maximum value constraint is exclusive, such a value is
invalid.</p>
<p><em>Input:</em></p>
<p>number at the schema's maximum allowed values boundary:</p>
<blockquote>
<pre><code class="language-json">4
</code></pre>
</blockquote>
<p>a schema with a maximum exclusive allowed value set:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;exclusiveMaximum&quot;: 4
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>an invalid range violation:</p>
<blockquote>
<ul>
<li>
<p>JSON value path: <code>$</code><br />
JSON schema path: <code>#/exclusiveMaximum</code></p>
<p>4.0 is outside of the valid range of (-Infinity,4.0)</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-an-array-containing-some-duplicated-strings-against-schema-not-accepting-duplicates"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-an-array-containing-some-duplicated-strings-against-schema-not-accepting-duplicates">finding JSON schema violations as a result of validating an array containing some duplicated strings against schema not accepting duplicates</a></h3>
<p>Because the schema requires items to be unique, and the value contains
duplicate occurrence, such a value is invalid.</p>
<p><em>Input:</em></p>
<p>an array containing some duplicated strings:</p>
<blockquote>
<pre><code class="language-json">[
  &quot;a&quot;,
  &quot;b&quot;,
  &quot;b&quot;,
  &quot;c&quot;,
  &quot;d&quot;,
  &quot;d&quot;,
  &quot;e&quot;
]
</code></pre>
</blockquote>
<p>schema not accepting duplicates:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;uniqueItems&quot;: true
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>an invalid array violation:</p>
<blockquote>
<ul>
<li>
<p>JSON value path: <code>$</code><br />
JSON schema path: <code>#</code></p>
<p>Invalid array:</p>
<ul>
<li>
<p>JSON value path: <code>$[1]</code><br />
JSON schema path: <code>#/uniqueItems</code></p>
<p>Non-unique array item.</p>
</li>
<li>
<p>JSON value path: <code>$[2]</code><br />
JSON schema path: <code>#/uniqueItems</code></p>
<p>Non-unique array item.</p>
</li>
<li>
<p>JSON value path: <code>$[4]</code><br />
JSON schema path: <code>#/uniqueItems</code></p>
<p>Non-unique array item.</p>
</li>
<li>
<p>JSON value path: <code>$[5]</code><br />
JSON schema path: <code>#/uniqueItems</code></p>
<p>Non-unique array item.</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-an-array-containing-a-mixture-of-null-and-boolean-values-to-a-schema-accepting-only-arrays-of-nulls-against-schema-accepting-only-arrays-of-nulls"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-an-array-containing-a-mixture-of-null-and-boolean-values-to-a-schema-accepting-only-arrays-of-nulls-against-schema-accepting-only-arrays-of-nulls">finding JSON schema violations as a result of validating an array containing a mixture of null and boolean values to a schema accepting only arrays of nulls against schema accepting only arrays of nulls</a></h3>
<p>Because the schema requires items to conform to a certain schema and
this is not the case here, such a value is invalid.</p>
<p><em>Input:</em></p>
<p>an array containing a mixture of null and boolean values to a schema
accepting only arrays of nulls:</p>
<blockquote>
<pre><code class="language-json">[
  null,
  false,
  null,
  true,
  null
]
</code></pre>
</blockquote>
<p>schema accepting only arrays of nulls:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;items&quot;: {
    &quot;type&quot;: [
      &quot;null&quot;
    ]
  },
  &quot;type&quot;: [
    &quot;array&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>an invalid array violation:</p>
<blockquote>
<ul>
<li>
<p>JSON value path: <code>$</code><br />
JSON schema path: <code>#</code></p>
<p>Invalid array:</p>
<ul>
<li>
<p>JSON value path: <code>$[1]</code><br />
JSON schema path: <code>#/items/type</code></p>
<p>Invalid type. Expected null but got boolean.</p>
</li>
<li>
<p>JSON value path: <code>$[3]</code><br />
JSON schema path: <code>#/items/type</code></p>
<p>Invalid type. Expected null but got boolean.</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-not-a-multiple-of-25-against-a-schema-accepting-only-multiples-of-25"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-not-a-multiple-of-25-against-a-schema-accepting-only-multiples-of-25">finding JSON schema violations as a result of validating not a multiple of 2.5 against a schema accepting only multiples of 2.5</a></h3>
<p>Because the schema accepts only multiples of 2.5, such a value is
invalid.</p>
<p><em>Input:</em></p>
<p>not a multiple of 2.5:</p>
<blockquote>
<pre><code class="language-json">7
</code></pre>
</blockquote>
<p>a schema accepting only multiples of 2.5:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;multipleOf&quot;: 2.5,
  &quot;type&quot;: [
    &quot;number&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>an invalid multiple violation:</p>
<blockquote>
<ul>
<li>
<p>JSON value path: <code>$</code><br />
JSON schema path: <code>#/multipleOf</code></p>
<p>7.0 is not a multiple of 2.5</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-number-below-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-exclusive-allowed-value-set"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-number-below-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-exclusive-allowed-value-set">finding JSON schema violations as a result of validating number below the schema's maximum allowed values boundary against a schema with a maximum exclusive allowed value set</a></h3>
<p>Because the value is less than the maximum value constraint, such a
value is valid.</p>
<p><em>Input:</em></p>
<p>number below the schema's maximum allowed values boundary:</p>
<blockquote>
<pre><code class="language-json">3
</code></pre>
</blockquote>
<p>a schema with a maximum exclusive allowed value set:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;exclusiveMaximum&quot;: 4
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no violations:</p>
<blockquote>
<p>∅</p>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-exclusive-allowed-value-set"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-exclusive-allowed-value-set">finding JSON schema violations as a result of validating number at the schema's minimum allowed values boundary against a schema with a minimum exclusive allowed value set</a></h3>
<p>Because the minimum value constraint is exclusive, such a value is
invalid.</p>
<p><em>Input:</em></p>
<p>number at the schema's minimum allowed values boundary:</p>
<blockquote>
<pre><code class="language-json">4
</code></pre>
</blockquote>
<p>a schema with a minimum exclusive allowed value set:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;exclusiveMinimum&quot;: 4
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>an invalid range violation:</p>
<blockquote>
<ul>
<li>
<p>JSON value path: <code>$</code><br />
JSON schema path: <code>#/exclusiveMinimum</code></p>
<p>4.0 is outside of the valid range of (4.0,Infinity)</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-inclusive-allowed-value-set"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-inclusive-allowed-value-set">finding JSON schema violations as a result of validating number at the schema's maximum allowed values boundary against a schema with a maximum inclusive allowed value set</a></h3>
<p>Because the maximum value constraint is inclusive, such a value is
valid.</p>
<p><em>Input:</em></p>
<p>number at the schema's maximum allowed values boundary:</p>
<blockquote>
<pre><code class="language-json">4
</code></pre>
</blockquote>
<p>a schema with a maximum inclusive allowed value set:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;maximum&quot;: 4
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no violations:</p>
<blockquote>
<p>∅</p>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-inclusive-allowed-value-set"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-number-at-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-inclusive-allowed-value-set">finding JSON schema violations as a result of validating number at the schema's minimum allowed values boundary against a schema with a minimum inclusive allowed value set</a></h3>
<p>Because the minimum value constraint is inclusive, such a value is
valid.</p>
<p><em>Input:</em></p>
<p>number at the schema's minimum allowed values boundary:</p>
<blockquote>
<pre><code class="language-json">4
</code></pre>
</blockquote>
<p>a schema with a minimum inclusive allowed value set:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;minimum&quot;: 4
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no violations:</p>
<blockquote>
<p>∅</p>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-number-exceeding-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-inclusive-allowed-value-set"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-number-exceeding-the-schemas-maximum-allowed-values-boundary-against-a-schema-with-a-maximum-inclusive-allowed-value-set">finding JSON schema violations as a result of validating number exceeding the schema's maximum allowed values boundary against a schema with a maximum inclusive allowed value set</a></h3>
<p>Because the value is greater than the maximum value constraint is
exclusive, such a value is invalid.</p>
<p><em>Input:</em></p>
<p>number exceeding the schema's maximum allowed values boundary:</p>
<blockquote>
<pre><code class="language-json">5
</code></pre>
</blockquote>
<p>a schema with a maximum inclusive allowed value set:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;maximum&quot;: 4
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>an invalid range violation:</p>
<blockquote>
<ul>
<li>
<p>JSON value path: <code>$</code><br />
JSON schema path: <code>#/maximum</code></p>
<p>5.0 is outside of the valid range of (-Infinity,4.0]</p>
</li>
</ul>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-number-below-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-exclusive-allowed-value-set"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-number-below-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-exclusive-allowed-value-set">finding JSON schema violations as a result of validating number below the schema's minimum allowed values boundary against a schema with a minimum exclusive allowed value set</a></h3>
<p>Because the value is less than the minimum value constraint, such a
value is valid.</p>
<p><em>Input:</em></p>
<p>number below the schema's minimum allowed values boundary:</p>
<blockquote>
<pre><code class="language-json">5
</code></pre>
</blockquote>
<p>a schema with a minimum exclusive allowed value set:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;exclusiveMinimum&quot;: 4
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>no violations:</p>
<blockquote>
<p>∅</p>
</blockquote>
<hr />
<h3 id="finding-json-schema-violations-as-a-result-of-validating-number-exceeding-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-inclusive-allowed-value-set"><a class="header" href="#finding-json-schema-violations-as-a-result-of-validating-number-exceeding-the-schemas-minimum-allowed-values-boundary-against-a-schema-with-a-minimum-inclusive-allowed-value-set">finding JSON schema violations as a result of validating number exceeding the schema's minimum allowed values boundary against a schema with a minimum inclusive allowed value set</a></h3>
<p>Because the value is greater than the minimum value constraint is
exclusive, such a value is invalid.</p>
<p><em>Input:</em></p>
<p>number exceeding the schema's minimum allowed values boundary:</p>
<blockquote>
<pre><code class="language-json">3
</code></pre>
</blockquote>
<p>a schema with a minimum inclusive allowed value set:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;minimum&quot;: 4
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>an invalid range violation:</p>
<blockquote>
<ul>
<li>
<p>JSON value path: <code>$</code><br />
JSON schema path: <code>#/minimum</code></p>
<p>3.0 is outside of the valid range of [4.0,Infinity)</p>
</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printing-a-json-valuerepresenting-a-json-schema"><a class="header" href="#printing-a-json-valuerepresenting-a-json-schema">Printing a JSON valuerepresenting a JSON schema</a></h1>
<h2 id="schema-3"><a class="header" href="#schema-3">Schema</a></h2>
<pre class="mermaid">flowchart LR
    subgraph inputs
        input_desc_0[&quot;JSON schema&quot;]
    end
    subgraph output
        output_desc[&quot;a JSON value&quot;]
    end
    inputs --&gt; output
</pre>
<h2 id="context-3"><a class="header" href="#context-3">Context</a></h2>
<h2 id="properties-2"><a class="header" href="#properties-2">Properties</a></h2>
<ul>
<li>always prints a well-formatted schema JSON</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value">Producing a JSON schema or an error as a result of parsing JSON value</a></h1>
<h2 id="schema-4"><a class="header" href="#schema-4">Schema</a></h2>
<pre class="mermaid">flowchart LR
    subgraph inputs
        input_desc_0[&quot;JSON value&quot;]
    end
    subgraph output
        output_desc[&quot;a JSON schema or an error&quot;]
    end
    inputs --&gt; output
</pre>
<h2 id="context-4"><a class="header" href="#context-4">Context</a></h2>
<p>JSON schema is commonly expressed in a JSON format. However, not every JSON is a valid JSON schema.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<ul>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-boolean-json-value">producing a JSON schema or an error as a result of parsing a boolean JSON value</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-set-to-an-array-with-a-single-null-string-inside-it">producing a JSON schema or an error as a result of parsing A JSON object with 'type' property set to an array with a single 'null' string inside it</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-defined">producing a JSON schema or an error as a result of parsing A JSON object with 'type' property defined</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-required-property-being-array-of-strings">producing a JSON schema or an error as a result of parsing A JSON object with 'required' property being array of strings</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-set-to-an-array-with-array-null-and-string-strings-inside-it">producing a JSON schema or an error as a result of parsing A JSON object with 'type' property set to an array with 'array', 'null' and 'string' strings inside it</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-uniqueitems-property-set">producing a JSON schema or an error as a result of parsing A JSON object with 'uniqueItems' property set</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-set-to-an-empty-array">producing a JSON schema or an error as a result of parsing A JSON object with 'type' property set to an empty array</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-value-not-being-a-boolean-or-object">producing a JSON schema or an error as a result of parsing a JSON value not being a boolean or object</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-an-json-object-with-the-not-property-defined">producing a JSON schema or an error as a result of parsing an JSON object with the 'not' property defined</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-an-json-object-with-the-items-property-defined">producing a JSON schema or an error as a result of parsing an JSON object with the 'items' property defined</a></p>
</li>
<li>
<p><a href="producing-a-json-schema-or-an-error-as-a-result-of-parsing-json-value.html#producing-a-json-schema-or-an-error-as-a-result-of-parsing-an-empty-json-object">producing a JSON schema or an error as a result of parsing an empty JSON object</a></p>
</li>
</ul>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-boolean-json-value"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-boolean-json-value">producing a JSON schema or an error as a result of parsing a boolean JSON value</a></h3>
<p>Because a boolean value of false is a valid schema which passes
validation of any JSON value, such a value represents a JSON schema.</p>
<p><em>Input:</em></p>
<p>a boolean JSON value:</p>
<blockquote>
<pre><code class="language-json">false
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">false
</code></pre>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-set-to-an-array-with-a-single-null-string-inside-it"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-set-to-an-array-with-a-single-null-string-inside-it">producing a JSON schema or an error as a result of parsing A JSON object with 'type' property set to an array with a single 'null' string inside it</a></h3>
<p>Because the 'type' keyword defines acceptable JSON types. It can be in a
form of an array of string (here, only with one type defined), such a
value represents a JSON schema.</p>
<p><em>Input:</em></p>
<p>A JSON object with 'type' property set to an array with a single 'null'
string inside it:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;null&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;null&quot;
  ]
}
</code></pre>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-defined"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-defined">producing a JSON schema or an error as a result of parsing A JSON object with 'type' property defined</a></h3>
<p>Because the 'type' keyword defines acceptable JSON types. It can be in a
form of a single string, such a value represents a JSON schema.</p>
<p><em>Input:</em></p>
<p>A JSON object with 'type' property defined:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;null&quot;
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;null&quot;
  ]
}
</code></pre>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-required-property-being-array-of-strings"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-required-property-being-array-of-strings">producing a JSON schema or an error as a result of parsing A JSON object with 'required' property being array of strings</a></h3>
<p>Because the 'required' constrain rejects any JSON object not containing
properties defined by it, such a value represents a JSON schema.</p>
<p><em>Input:</em></p>
<p>A JSON object with 'required' property being array of strings:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;required&quot;: [
    &quot;prop1&quot;,
    &quot;prop2&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;required&quot;: [
    &quot;prop1&quot;,
    &quot;prop2&quot;
  ]
}
</code></pre>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-set-to-an-array-with-array-null-and-string-strings-inside-it"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-set-to-an-array-with-array-null-and-string-strings-inside-it">producing a JSON schema or an error as a result of parsing A JSON object with 'type' property set to an array with 'array', 'null' and 'string' strings inside it</a></h3>
<p>Because the 'type' keyword defines acceptable JSON types. It can be in a
form of an array of string (here, with three types defined), such a
value represents a JSON schema.</p>
<p><em>Input:</em></p>
<p>A JSON object with 'type' property set to an array with 'array', 'null'
and 'string' strings inside it:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;array&quot;,
    &quot;null&quot;,
    &quot;string&quot;
  ]
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: [
    &quot;array&quot;,
    &quot;null&quot;,
    &quot;string&quot;
  ]
}
</code></pre>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-uniqueitems-property-set"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-uniqueitems-property-set">producing a JSON schema or an error as a result of parsing A JSON object with 'uniqueItems' property set</a></h3>
<p>Because the 'uniqueItems' keyword makes sure that if JSON value is an
array, its items do not contain any duplicates, such a value represents
a JSON schema.</p>
<p><em>Input:</em></p>
<p>A JSON object with 'uniqueItems' property set:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;uniqueItems&quot;: true
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;uniqueItems&quot;: true
}
</code></pre>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-set-to-an-empty-array"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-object-with-type-property-set-to-an-empty-array">producing a JSON schema or an error as a result of parsing A JSON object with 'type' property set to an empty array</a></h3>
<p>Because the 'type' keyword defines acceptable JSON types. It can be in a
form of an array of string (here, with no types defined), such a value
represents a JSON schema.</p>
<p><em>Input:</em></p>
<p>A JSON object with 'type' property set to an empty array:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: []
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;type&quot;: []
}
</code></pre>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-value-not-being-a-boolean-or-object"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-a-json-value-not-being-a-boolean-or-object">producing a JSON schema or an error as a result of parsing a JSON value not being a boolean or object</a></h3>
<p>Because booleans and objects are the only acceptable forms, such a value
does not represent a JSON schema.</p>
<p><em>Input:</em></p>
<p>a JSON value not being a boolean or object:</p>
<blockquote>
<pre><code class="language-json">0
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a parsing error:</p>
<blockquote>
<p>an error:</p>
<p><code>&quot;the JSON value is neither a boolean nor an object&quot;</code></p>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-an-json-object-with-the-not-property-defined"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-an-json-object-with-the-not-property-defined">producing a JSON schema or an error as a result of parsing an JSON object with the 'not' property defined</a></h3>
<p>Because the 'not' constrain rejects any JSON value which conform to
schema defined by it, such a value represents a JSON schema.</p>
<p><em>Input:</em></p>
<p>an JSON object with the 'not' property defined:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;not&quot;: true
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;not&quot;: true
}
</code></pre>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-an-json-object-with-the-items-property-defined"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-an-json-object-with-the-items-property-defined">producing a JSON schema or an error as a result of parsing an JSON object with the 'items' property defined</a></h3>
<p>Because the 'items' constrain makes sure than if a JSON value is an
array, every item of that array conforms the schema defined by it, such
a value represents a JSON schema.</p>
<p><em>Input:</em></p>
<p>an JSON object with the 'items' property defined:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;items&quot;: true
}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">{
  &quot;items&quot;: true
}
</code></pre>
</blockquote>
<hr />
<h3 id="producing-a-json-schema-or-an-error-as-a-result-of-parsing-an-empty-json-object"><a class="header" href="#producing-a-json-schema-or-an-error-as-a-result-of-parsing-an-empty-json-object">producing a JSON schema or an error as a result of parsing an empty JSON object</a></h3>
<p>Because an empty JSON object is a valid schema which passes validation
of any JSON value, such a value represents a JSON schema.</p>
<p><em>Input:</em></p>
<p>an empty JSON object:</p>
<blockquote>
<pre><code class="language-json">{}
</code></pre>
</blockquote>
<p><em>Output:</em></p>
<p>a successfully parsed JSON schema:</p>
<blockquote>
<pre><code class="language-json">{}
</code></pre>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
